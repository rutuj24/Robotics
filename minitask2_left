import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist
import numpy as np
import math
import random

# --- Parameters ---
TARGET_DISTANCE = 0.55      # Target distance to maintain from wall (meters)
LINEAR_SPEED = 0.25         # Forward speed (m/s)
KP_DISTANCE = 1.2           # Proportional gain for distance error
KP_ANGLE = 1.5              # Proportional gain for angle error
WALL_PRESENCE_THRESHOLD = 3.0 # Max distance to consider a wall 'present' (meters)
FRONT_AVOID_ANGLE = 45      # Degrees forward for obstacle check (+/- 45)
OBSTACLE_THRESHOLD = 0.45   # Minimum safe distance for obstacles (meters)
A_ANGLE_RIGHT_DEG = 285     # Rear angle for right wall detection
B_ANGLE_RIGHT_DEG = 330     # Front angle for right wall detection
A_ANGLE_LEFT_DEG = 75       # Rear angle for left wall detection
B_ANGLE_LEFT_DEG = 30       # Front angle for left wall detection
RANDOM_WALK_TIME = 50       # Number of scan cycles for a random walk step

class RobotState:
    """Enumeration for robot behavior states"""
    RANDOM_WALK = 0
    WALL_FOLLOW = 1
    OBSTACLE_AVOID = 2

class Minitask2Bot(Node):
    def __init__(self):
        super().__init__('minitask2bot')
        
        # Publisher for robot movement commands
        self.publisher_ = self.create_publisher(Twist, '/cmd_vel', 10)
        
        # QoS profile for LIDAR - required for real robot compatibility
        qos_profile = QoSProfile(
            reliability=ReliabilityPolicy.BEST_EFFORT,
            depth=10
        )
        
        # Subscriber for LIDAR data with QoS settings
        self.subscriber = self.create_subscription(
            LaserScan, '/scan', self.scan_callback, qos_profile)
        
        self.get_logger().info('Minitask2 Node started with QoS BEST_EFFORT.')
        
        # State machine initialization
        self.state = RobotState.RANDOM_WALK
        self.random_walk_counter = 0
        self.last_twist = Twist()
        
        # For detecting circular wall following (optional enhancement)
        self.wall_follow_time = 0
        self.max_wall_follow_time = 500  # Force exploration after 500 cycles

    def get_index_for_angle(self, msg, angle_deg):
        """
        Convert angle in degrees to LIDAR array index.
        Works with any number of LIDAR readings (not just 360).
        
        Args:
            msg: LaserScan message
            angle_deg: Angle in degrees (0-359)
        
        Returns:
            Index in the ranges array
        """
        num_readings = len(msg.ranges)
        # Convert degree to index based on actual number of readings
        index = int((angle_deg / 360.0) * num_readings)
        return min(max(index, 0), num_readings - 1)

    def get_safe_distance(self, ranges, index):
        """
        Get distance reading with safe handling of invalid values.
        
        Args:
            ranges: Array of LIDAR distance readings
            index: Index to read from
        
        Returns:
            Distance in meters, or large value if invalid
        """
        if index < 0 or index >= len(ranges):
            return 100.0
        
        r = ranges[index]
        
        # Handle infinity, NaN, and invalid readings
        if np.isinf(r) or np.isnan(r) or r <= 0.0:
            return 100.0
        
        return r

    def calculate_steering(self, dist_A, dist_B, side):
        """
        Calculate steering angle using proportional control.
        Uses two LIDAR points (A=rear, B=front) to maintain parallel wall following.
        
        Args:
            dist_A: Distance to wall at rear measurement point
            dist_B: Distance to wall at front measurement point
            side: 'RIGHT' or 'LEFT' to indicate which side the wall is on
        
        Returns:
            Tuple of (angular_z, angle_alpha, distance_error)
        """
        # Calculate angle between the two measurement points (45 degrees)
        angle_diff_rad = np.radians(45)
        
        # Calculate the angle alpha (robot's orientation relative to wall)
        if dist_A == 0.0 or dist_B == 0.0 or angle_diff_rad == 0:
            angle_alpha = 0.0
        else:
            angle_alpha = math.atan2(
                dist_A * math.cos(angle_diff_rad) - dist_B,
                dist_A * math.sin(angle_diff_rad)
            )
        
        # Calculate how far we are from target distance
        distance_error = TARGET_DISTANCE - dist_B
        
        # Apply proportional control
        angle_correction = -KP_ANGLE * angle_alpha
        distance_correction = KP_DISTANCE * distance_error
        
        # Combine corrections based on which side the wall is on
        if side == 'RIGHT':
            angular_z = angle_correction + distance_correction
        else:  # LEFT
            angular_z = (-angle_correction) - distance_correction
        
        return angular_z, angle_alpha, distance_error

    def random_walk(self):
        """
        Execute random walk behavior for exploration.
        Drives forward, then occasionally turns in a random direction.
        """
        self.random_walk_counter += 1
        
        if self.random_walk_counter >= RANDOM_WALK_TIME:
            # Time for a new random action
            action = random.choice(['forward', 'forward', 'turn'])  # Bias toward forward
            
            if action == 'forward':
                linear_x = LINEAR_SPEED * random.uniform(0.6, 1.0)
                angular_z = 0.0
            else:  # turn
                linear_x = LINEAR_SPEED * 0.3  # Slow down while turning
                angular_z = random.uniform(-1.5, 1.5)
            
            self.random_walk_counter = 0
            self.get_logger().info(f'RANDOM WALK: New action - Moving {linear_x:.2f}, Turning {angular_z:.2f}')
        else:
            # Continue moving forward
            linear_x = LINEAR_SPEED * 0.8
            angular_z = 0.0
        
        self.move_robot(linear_x, angular_z)

    def scan_callback(self, msg: LaserScan):
        """
        Main LIDAR callback - implements state machine logic.
        Processes LIDAR data and decides which behavior to execute.
        
        Args:
            msg: LaserScan message from LIDAR
        """
        num_readings = len(msg.ranges)
        
        # --- PRIORITY 1: Emergency Obstacle Avoidance ---
        # Check for obstacles directly in front of robot
        
        # Calculate indices for front arc based on actual number of readings
        front_angle_rad = math.radians(FRONT_AVOID_ANGLE)
        angle_per_reading = (2 * math.pi) / num_readings
        front_range = int(front_angle_rad / angle_per_reading)
        
        # Get indices for front arc (wraps around at 0/360)
        front_indices = list(range(0, min(front_range + 1, num_readings))) + \
                        list(range(max(num_readings - front_range, 0), num_readings))
        
        # Find minimum distance in front arc
        front_min_distance = float('inf')
        for i in front_indices:
            if i < num_readings:
                r = msg.ranges[i]
                if not np.isinf(r) and not np.isnan(r) and r > msg.range_min:
                    front_min_distance = min(front_min_distance, r)
        
        # Check if obstacle is too close
        if front_min_distance < OBSTACLE_THRESHOLD:
            self.state = RobotState.OBSTACLE_AVOID
            self.wall_follow_time = 0  # Reset wall follow timer
        else:
            # --- PRIORITY 2: Wall Following ---
            # Check for walls on right side
            idx_AR = self.get_index_for_angle(msg, A_ANGLE_RIGHT_DEG)
            idx_BR = self.get_index_for_angle(msg, B_ANGLE_RIGHT_DEG)
            dist_AR = self.get_safe_distance(msg.ranges, idx_AR)
            dist_BR = self.get_safe_distance(msg.ranges, idx_BR)
            wall_on_right = dist_BR < WALL_PRESENCE_THRESHOLD

            # Check for walls on left side
            idx_AL = self.get_index_for_angle(msg, A_ANGLE_LEFT_DEG)
            idx_BL = self.get_index_for_angle(msg, B_ANGLE_LEFT_DEG)
            dist_AL = self.get_safe_distance(msg.ranges, idx_AL)
            dist_BL = self.get_safe_distance(msg.ranges, idx_BL)
            wall_on_left = dist_BL < WALL_PRESENCE_THRESHOLD

            # Decide state based on wall presence
            if wall_on_right or wall_on_left:
                self.state = RobotState.WALL_FOLLOW
                self.wall_follow_time += 1
                
                # Optional: Force exploration if following wall too long
                if self.wall_follow_time > self.max_wall_follow_time:
                    self.get_logger().info('Been following wall too long, switching to exploration...')
                    self.state = RobotState.RANDOM_WALK
                    self.wall_follow_time = 0
            else:
                # --- PRIORITY 3: Random Walk (Exploration) ---
                self.state = RobotState.RANDOM_WALK
                self.wall_follow_time = 0

        # --- Execute Selected Behavior ---
        if self.state == RobotState.OBSTACLE_AVOID:
            # Emergency avoidance: Stop and turn away from obstacle
            turn_direction = 1.5 if random.random() > 0.5 else -1.5
            self.get_logger().warn(f'OBSTACLE AVOID: {front_min_distance:.2f}m ahead! Turning...')
            self.move_robot(0.0, turn_direction)
            
        elif self.state == RobotState.WALL_FOLLOW:
            # Decide which wall to follow
            
            # *** FIX IS HERE ***
            if wall_on_right and wall_on_left:
                # Both walls present - choose the (absolutely) NEAREST wall.
                target_side = 'RIGHT' if dist_BR <= dist_BL else 'LEFT'
                self.get_logger().info(f'CORRIDOR: Nearest wall is {target_side} ({dist_BR:.2f}m vs {dist_BL:.2f}m)')
                
            elif wall_on_right:
                target_side = 'RIGHT'
            else:
                target_side = 'LEFT'
            
            # Calculate steering for wall following
            if target_side == 'RIGHT':
                angular_z, angle_alpha, dist_error = self.calculate_steering(
                    dist_AR, dist_BR, target_side)
                self.get_logger().info(
                    f'WALL FOLLOW RIGHT: dist={dist_BR:.2f}m, angle={math.degrees(angle_alpha):.1f}°, '
                    f'steering={angular_z:.2f}')
            else:
                angular_z, angle_alpha, dist_error = self.calculate_steering(
                    dist_AL, dist_BL, target_side)
                self.get_logger().info(
                    f'WALL FOLLOW LEFT: dist={dist_BL:.2f}m, angle={math.degrees(angle_alpha):.1f}°, '
                    f'steering={angular_z:.2f}')
            
            # Limit angular velocity for safety and stability
            angular_z = max(-2.0, min(2.0, angular_z))
            self.move_robot(LINEAR_SPEED, angular_z)
            
        elif self.state == RobotState.RANDOM_WALK:
            # Exploration behavior
            self.random_walk()
            
        else:
            # Should never reach here - safety stop
            self.get_logger().error('Unknown state! Stopping.')
            self.move_robot(0.0, 0.0)

    def move_robot(self, linear_x, angular_z):
        """
        Publish movement command to robot.
        
        Args:
            linear_x: Forward velocity (m/s)
            angular_z: Angular velocity (rad/s)
        """
        twist_msg = Twist()
        twist_msg.linear.x = float(linear_x)
        twist_msg.angular.z = float(angular_z)
        self.publisher_.publish(twist_msg)
        self.last_twist = twist_msg

def main(args=None):
    rclpy.init(args=args)
    bot = Minitask2Bot()
    
    try:
        rclpy.spin(bot)
    except KeyboardInterrupt:
        bot.get_logger().info('Stopped by user.')
        bot.move_robot(0.0, 0.0)
    finally:
        bot.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
