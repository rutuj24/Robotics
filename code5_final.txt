import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from nav_msgs.msg import Odometry
import math

class SquareMover(Node):

    def __init__(self):
        super().__init__('square_mover')
        
        # --- Parameters ---
        self.side_length = 1  # Length of the square side in meters
        self.linear_speed = 0.2 # Linear speed in m/s
        self.angular_speed = 0.2 # Angular speed in rad/s
        self.angle_tolerance = 0.01 # Tolerance for reaching target angle (in radians)

        # --- Publisher and Subscriber ---
        self.publisher_ = self.create_publisher(Twist, '/cmd_vel', 10)
        self.subscription = self.create_subscription(
            Odometry,
            '/odom',
            self.odom_callback,
            10)
        
        # --- State Machine Variables ---
        self.states = ['MOVING_FORWARD', 'TURNING']
        self.current_state = 'MOVING_FORWARD'
        
        # --- Position and Orientation Variables ---
        self.start_position = None
        self.start_yaw = None
        self.current_position = None
        self.current_yaw = 0.0
        
        
    def odom_callback(self, msg):
        self.current_position = msg.pose.pose.position
        orientation_q = msg.pose.pose.orientation
        
        # Convert quaternion to Euler angles to get the yaw
        x = orientation_q.x
        y = orientation_q.y
        z = orientation_q.z
        w = orientation_q.w
        siny_cosp = 2 * (w * z + x * y)
        cosy_cosp = 1 - 2 * (y * y + z * z)
        yaw = math.atan2(siny_cosp, cosy_cosp)
        self.current_yaw = yaw 
        
        if self.start_position is None:
            self.start_position = self.current_position
            self.start_yaw = self.current_yaw

        if self.current_state == 'MOVING_FORWARD':
            self.move_forward()
        elif self.current_state == 'TURNING':
            self.turn()

    def move_forward(self):
        """
        Handles the logic for moving the robot forward.
        """
        distance_moved = math.sqrt(
            (self.current_position.x - self.start_position.x)**2 +
            (self.current_position.y - self.start_position.y)**2
        )
        
        if distance_moved < self.side_length :
            twist_msg = Twist()
            twist_msg.linear.x = self.linear_speed
            self.publisher_.publish(twist_msg)
        else:
            self.get_logger().info('Finished moving forward. Starting turn.')
            twist_msg = Twist()
            self.publisher_.publish(twist_msg)            
            self.current_state = 'TURNING'
            # Record the angle at the start of the turn
            self.start_yaw = self.current_yaw

    def turn(self):
        """
        Handles the logic for turning the robot 90 degrees.
        """
        target_yaw = self.normalize_angle(self.start_yaw + math.pi / 2.0)
        angle_diff = self.normalize_angle(target_yaw - self.current_yaw)

        if abs(angle_diff) > self.angle_tolerance:
            twist_msg = Twist()
            # Turn counter-clockwise
            twist_msg.angular.z = self.angular_speed
            self.publisher_.publish(twist_msg)
        else:
            self.get_logger().info('Finished turning. Moving forward.')
            twist_msg = Twist()
            self.publisher_.publish(twist_msg)
            self.current_state = 'MOVING_FORWARD'
            # Record the position at the start of the new side
            self.start_position = self.current_position
            

    def normalize_angle(self, angle):
        """
        Normalizes an angle to be within the range [-pi, pi].
        """
        while angle > math.pi:
            angle -= 2.0 * math.pi
        while angle < -math.pi:
            angle += 2.0 * math.pi
        return angle

def main(args=None):
    rclpy.init(args=args)
    square_mover = SquareMover()
    rclpy.spin(square_mover)

    square_mover.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
