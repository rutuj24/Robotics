import rclpy
from rclpy.node import Node

import time

from geometry_msgs.msg import Twist
from geometry_msgs.msg import Vector3
from geometry_msgs.msg import Quaternion
from nav_msgs.msg import Odometry

import numpy as np
import math

from enum import Enum


class State(Enum):
    START = 0
    MOVING_FORWARDS = 1
    REACHED_TARGET_POS = 2
    TURNING = 3
    REACHED_TARGET_ROT = 4


def euclidean_distance_squared(vec1: Vector3, vec2: Vector3) -> float:
    x = vec1.x - vec2.x
    y = vec1.y - vec2.y
    z = vec1.z - vec2.z
    return x * x + y * y + z * z


def quaternion_angle(q1: Quaternion, q2: Quaternion) -> float:
    """
    Calculate the angle in radians between two quaternions.

    Parameters:
    q1 (list or np.ndarray): The first quaternion as a list or array of length 4.
    q2 (list or np.ndarray): The second quaternion as a list or array of length 4.

    Returns:
    float: The angle in radians between the two quaternions.
    """
    # Normalize the quaternions
    q1 = np.array([q1.x, q1.y, q1.z, q1.w])
    q2 = np.array([q2.x, q2.y, q2.z, q2.w])

    q1_norm = q1 / np.linalg.norm(q1)
    q2_norm = q2 / np.linalg.norm(q2)

    # Compute the dot product
    dot_product = np.dot(q1_norm, q2_norm)

    # Clamp the dot product to avoid floating point errors
    dot_product = np.clip(dot_product, -1.0, 1.0)

    # Calculate the angle
    angle = np.arccos(dot_product)

    return angle


class Minitask1(Node):
    def __init__(self):
        super().__init__("minitask1")
        # create the publisher
        self.publisher_ = self.create_publisher(Twist, "cmd_vel", 10)
        timer_period = 10.0  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)

        # create the subscriber
        self.subscription = self.create_subscription(
            Odometry, "odom", self.odom_callback, 10
        )
        self.subscription  # prevent unused variable warning
        self.last_position = Vector3()
        self.last_orientation = Quaternion()
        self.state = State.START
        self.target_distance = 0.75

        self.i = 0

    # publish a message every 0.5 seconds
    def timer_callback(self):
        pass
        
    def new_twist(self) -> Twist:
        t = Twist()
        l = Vector3()
        l.x = 0.0
        l.y = 0.0
        l.z = 0.0
        a = Vector3()
        a.x = 0.0
        a.y = 0.0
        a.z = 0.0
        t.linear = l
        t.angular = a
        return t

    def move_forward(self) -> None:
        twist = self.new_twist()
        twist.linear.x = 1.0
        self.publisher_.publish(twist)
        self.get_logger().info("Publishing the move forward")

    def stop_moving(self) -> None:
        twist = self.new_twist()
        self.publisher_.publish(twist)
        self.get_logger().info("Stopping robot")

    # turning speed in radians per second
    def start_turning(self, turning_speed: float) -> None:
        twist = self.new_twist()
        twist.angular.z = turning_speed
        self.publisher_.publish(twist)
        self.get_logger().info("Started turning")

    def odom_callback(self, msg):
        location = msg.pose.pose.position
        orientation = msg.pose.pose.orientation
        match self.state:
            case State.START:
                self.last_position = location
                self.last_orientation = orientation
                self.move_forward()
                self.state = State.MOVING_FORWARDS
            case State.MOVING_FORWARDS:
                distance_squared = euclidean_distance_squared(
                    location, self.last_position
                )
                if distance_squared > self.target_distance * self.target_distance:
                    self.state = State.REACHED_TARGET_POS
                    self.stop_moving()
            case State.REACHED_TARGET_POS:
                turning_speed = 0.2
                self.start_turning(turning_speed)
                self.state = State.TURNING
            case State.TURNING:
                radians = quaternion_angle(orientation, self.last_orientation)
                if radians >= math.pi / 4:
                    self.stop_moving()
                    self.state = State.REACHED_TARGET_ROT
            case State.REACHED_TARGET_ROT:
                # self.get_logger().log("Completed one line")
                self.state = State.START


def main(args=None):
    rclpy.init(args=args)

    mt = Minitask1()

    rclpy.spin(mt)

    # Destroy the node explicitly
    # (optional - otherwise it will be done automatically
    # when the garbage collector destroys the node object)
    mt.destroy_node()
    rclpy.shutdown()


if __name__ == "__main__":
    main()
