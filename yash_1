#!/usr/bin/env python3
import math
import time
from typing import Optional, Tuple, List

import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.qos import (
    QoSProfile,
    qos_profile_sensor_data,
    ReliabilityPolicy,
    DurabilityPolicy,
)

import cv2
import numpy as np
from cv_bridge import CvBridge, CvBridgeError

from geometry_msgs.msg import Twist, PoseWithCovarianceStamped
from sensor_msgs.msg import Image, LaserScan
from visualization_msgs.msg import Marker, MarkerArray
from nav2_msgs.action import NavigateToPose
from action_msgs.msg import GoalStatus


class TreasureHuntNode(Node):
    """
    Single ROS2 node that:
    - Localises with AMCL and uses Nav2 for global navigation.
    - Systematically explores a known map with a grid of waypoints.
    - Uses RGB camera to detect:
        * Red fire hydrants
        * Green FIRST 2015 trash cans
    - When an object is detected:
        * Interrupts Nav2
        * Turns to centre the object
        * Approaches to a safe distance using LIDAR
        * Estimates object position in map frame
        * Publishes a visualization marker in RViz
        * Stores detections to avoid duplicates
    - Resumes exploration after object handling.
    - Enforces a 5-minute maximum runtime (configurable).
    """

    # ---- FSM States ----
    STATE_IDLE = "IDLE"
    STATE_NAVIGATING = "NAVIGATING"
    STATE_TURN_TO_OBJECT = "TURN_TO_OBJECT"
    STATE_APPROACH_OBJECT = "APPROACH_OBJECT"
    STATE_BACKING_UP = "BACKING_UP"
    STATE_SPINNING_AWAY = "SPINNING_AWAY"
    STATE_FINISHED = "FINISHED"

    def __init__(self) -> None:
        super().__init__("treasure_hunt_node")

        # ---------------- Parameters ----------------
        # Topics
        self.declare_parameter("camera_topic", "/camera/image_raw")
        self.declare_parameter("scan_topic", "/scan")
        self.declare_parameter("cmd_vel_topic", "/cmd_vel")
        self.declare_parameter("amcl_topic", "/amcl_pose")
        self.declare_parameter("map_frame", "map")

        # Detection tuning
        self.declare_parameter("min_contour_area", 800.0)
        self.declare_parameter("center_tolerance", 0.1)  # Normalised offset [-1,1]
        self.declare_parameter("safe_object_distance", 0.8)

        # Motion tuning
        self.declare_parameter("max_linear_speed", 0.2)
        self.declare_parameter("max_angular_speed", 0.5)

        # Waypoint / Nav2 tuning
        self.declare_parameter("waypoint_dist_tolerance", 0.3)
        self.declare_parameter("stuck_progress_threshold", 0.05)  # m
        self.declare_parameter("stuck_timeout", 15.0)  # s

        # Global runtime limit (seconds)
        self.declare_parameter("max_runtime_sec", 5 * 60.0)

        camera_topic = self.get_parameter("camera_topic").get_parameter_value().string_value
        scan_topic = self.get_parameter("scan_topic").get_parameter_value().string_value
        cmd_vel_topic = self.get_parameter("cmd_vel_topic").get_parameter_value().string_value
        amcl_topic = self.get_parameter("amcl_topic").get_parameter_value().string_value
        self.map_frame = self.get_parameter("map_frame").get_parameter_value().string_value

        self.min_contour_area = float(self.get_parameter("min_contour_area").value)
        self.center_tolerance = float(self.get_parameter("center_tolerance").value)
        self.safe_object_distance = float(self.get_parameter("safe_object_distance").value)
        self.max_linear_speed = float(self.get_parameter("max_linear_speed").value)
        self.max_angular_speed = float(self.get_parameter("max_angular_speed").value)
        self.waypoint_dist_tolerance = float(self.get_parameter("waypoint_dist_tolerance").value)
        self.stuck_progress_threshold = float(self.get_parameter("stuck_progress_threshold").value)
        self.stuck_timeout = float(self.get_parameter("stuck_timeout").value)
        self.max_runtime_sec = float(self.get_parameter("max_runtime_sec").value)

        # ---------------- QoS Profiles ----------------
        sensor_qos = qos_profile_sensor_data

        amcl_qos = QoSProfile(
            depth=1,
            durability=DurabilityPolicy.TRANSIENT_LOCAL,
            reliability=ReliabilityPolicy.RELIABLE,
        )

        camera_qos = QoSProfile(
            depth=1,
            durability=DurabilityPolicy.VOLATILE,
            reliability=ReliabilityPolicy.RELIABLE,
        )

        # ---------------- Publishers ----------------
        self.cmd_pub = self.create_publisher(Twist, cmd_vel_topic, 10)
        self.marker_pub = self.create_publisher(Marker, "/detected_objects", 10)
        self.waypoint_marker_pub = self.create_publisher(MarkerArray, "/waypoint_markers", 10)

        # ---------------- Subscribers ----------------
        self.image_sub = self.create_subscription(
            Image, camera_topic, self.image_callback, camera_qos
        )
        self.scan_sub = self.create_subscription(
            LaserScan, scan_topic, self.scan_callback, sensor_qos
        )
        self.pose_sub = self.create_subscription(
            PoseWithCovarianceStamped, amcl_topic, self.pose_callback, amcl_qos
        )

        # ---------------- Action Client (Nav2) ----------------
        self.nav_client = ActionClient(self, NavigateToPose, "navigate_to_pose")

        # ---------------- Helpers & State ----------------
        self.bridge = CvBridge()

        # Robot pose
        self.robot_pose = {"x": 0.0, "y": 0.0, "yaw": 0.0}
        self.have_pose = False

        # Nav2 state
        self.goal_handle = None
        self.navigation_active = False
        self.current_waypoint: Optional[Tuple[float, float]] = None
        self.cancel_reason = "NONE"
        self.last_dist_remaining = float("inf")
        self.progress_timer = time.time()
        self.goal_start_time = time.time()

        # LIDAR
        self.front_distance: Optional[float] = None

        # Vision
        self.current_detection = None  # dict with keys: type, offset, area
        self.last_detection_time = 0.0
        self.detection_persistence_sec = 0.5  # keep detection briefly after lost

        # Found objects
        self.found_objects: List[dict] = []
        self.marker_id_counter = 0

        # Behaviour FSM
        self.state = self.STATE_IDLE
        self.backup_counter = 0
        self.turn_away_counter = 0

        # Runtime tracking
        self.start_wall_time = time.time()

        # Waypoints: dense grid covering the provided training world
        self.unvisited_waypoints: List[Tuple[float, float]] = []
        # X: [-1.6, 5.6], Y: [-3.7, 3.9], step 2.0 (same as your original)
        for x in np.arange(-1.6, 5.7, 2.0):
            for y in np.arange(-3.7, 4.0, 2.0):
                self.unvisited_waypoints.append((float(x), float(y)))

        # HSV thresholds (tuned for Gazebo’s hydrant/bin textures)
        self.red_lower_1 = np.array([0, 185, 140])
        self.red_upper_1 = np.array([10, 255, 255])
        self.red_lower_2 = np.array([170, 185, 140])
        self.red_upper_2 = np.array([180, 255, 255])

        self.green_lower = np.array([35, 80, 50])
        self.green_upper = np.array([85, 255, 255])

        # Loop counter for periodic debug / marker publishing
        self.loop_count = 0

        self.get_logger().info(
            f"TreasureHuntNode started. Camera: {camera_topic}, Nav2: navigate_to_pose"
        )

        # Main control loop at 10 Hz
        self.timer = self.create_timer(0.1, self.control_loop)

    # ============================================================
    # Callbacks
    # ============================================================

    def pose_callback(self, msg: PoseWithCovarianceStamped) -> None:
        pose = msg.pose.pose
        self.robot_pose["x"] = pose.position.x
        self.robot_pose["y"] = pose.position.y

        q = pose.orientation
        # yaw from quaternion
        siny_cosp = 2.0 * (q.w * q.z + q.x * q.y)
        cosy_cosp = 1.0 - 2.0 * (q.y * q.y + q.z * q.z)
        self.robot_pose["yaw"] = math.atan2(siny_cosp, cosy_cosp)

        self.have_pose = True

    def scan_callback(self, msg: LaserScan) -> None:
        ranges = msg.ranges
        if not ranges:
            self.front_distance = None
            return

        # Front sector ±15 degrees
        front_ranges = list(ranges[0:30]) + list(ranges[-30:])
        valid = [r for r in front_ranges if math.isfinite(r) and 0.05 < r < 10.0]
        self.front_distance = float(min(valid)) if valid else None

    def image_callback(self, msg: Image) -> None:
        try:
            cv_image = self.bridge.imgmsg_to_cv2(msg, "bgr8")
        except CvBridgeError as e:
            self.get_logger().error(f"CVBridge error: {e}")
            return

        hsv = cv2.cvtColor(cv_image, cv2.COLOR_BGR2HSV)
        height, width, _ = cv_image.shape

        # --- Red mask ---
        mask_r1 = cv2.inRange(hsv, self.red_lower_1, self.red_upper_1)
        mask_r2 = cv2.inRange(hsv, self.red_lower_2, self.red_upper_2)
        mask_red = cv2.bitwise_or(mask_r1, mask_r2)

        # --- Green mask ---
        mask_green = cv2.inRange(hsv, self.green_lower, self.green_upper)

        # Optional morphological operations for robustness
        kernel = np.ones((5, 5), np.uint8)
        mask_red = cv2.morphologyEx(mask_red, cv2.MORPH_OPEN, kernel)
        mask_red = cv2.morphologyEx(mask_red, cv2.MORPH_DILATE, kernel)

        mask_green = cv2.morphologyEx(mask_green, cv2.MORPH_OPEN, kernel)
        mask_green = cv2.morphologyEx(mask_green, cv2.MORPH_DILATE, kernel)

        # Find blobs
        red_det = self.find_blob(mask_red, width)
        green_det = self.find_blob(mask_green, width)

        candidates = []
        if red_det is not None:
            candidates.append({"type": "hydrant", **red_det})
        if green_det is not None:
            candidates.append({"type": "trash_can", **green_det})

        if not candidates:
            # Don't drop detection instantly — small persistence to avoid flickering
            if time.time() - self.last_detection_time > self.detection_persistence_sec:
                self.current_detection = None
            return

        best = max(candidates, key=lambda d: d["area"])
        self.current_detection = best
        self.last_detection_time = time.time()

    def find_blob(self, mask: np.ndarray, width: int) -> Optional[dict]:
        contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        if not contours:
            return None

        largest = max(contours, key=cv2.contourArea)
        area = cv2.contourArea(largest)
        if area < self.min_contour_area:
            return None

        M = cv2.moments(largest)
        if M["m00"] == 0:
            return None

        cx = int(M["m10"] / M["m00"])
        offset = (cx - width / 2.0) / (width / 2.0)  # [-1, 1]
        return {"cx": cx, "offset": offset, "area": area}

    # ============================================================
    # Nav2 helpers
    # ============================================================

    def send_nav_goal(self, x: float, y: float) -> bool:
        """Send a Nav2 NavigateToPose goal."""
        if not self.nav_client.wait_for_server(timeout_sec=2.0):
            self.get_logger().warn("Nav2 action server not available.")
            return False

        goal_msg = NavigateToPose.Goal()
        goal_msg.pose.header.frame_id = self.map_frame
        goal_msg.pose.header.stamp = self.get_clock().now().to_msg()
        goal_msg.pose.pose.position.x = float(x)
        goal_msg.pose.pose.position.y = float(y)
        goal_msg.pose.pose.orientation.w = 1.0  # yaw=0

        self.get_logger().info(f"Sending Nav2 goal: ({x:.2f}, {y:.2f})")

        self.cancel_reason = "NONE"
        self.last_dist_remaining = float("inf")
        self.progress_timer = time.time()
        self.goal_start_time = time.time()

        send_future = self.nav_client.send_goal_async(
            goal_msg, feedback_callback=self.feedback_callback
        )
        send_future.add_done_callback(self.goal_response_callback)
        return True

    def feedback_callback(self, feedback_msg) -> None:
        """Monitor distance to goal for tolerance & stuck detection."""
        dist = feedback_msg.feedback.distance_remaining
        now = time.time()

        # Ignore weird early feedback for 2 seconds
        if (now - self.goal_start_time) < 2.0:
            return

        if dist == 0.0:
            return

        # Close enough to consider waypoint reached
        if dist < self.waypoint_dist_tolerance:
            if self.navigation_active and self.cancel_reason == "NONE":
                self.get_logger().info(
                    f"Waypoint reached within tolerance ({dist:.2f} m)."
                )
                self.cancel_reason = "REACHED"
                self.cancel_nav_goal()
                return

        # Stuck detection: no progress for stuck_timeout seconds
        if (self.last_dist_remaining - dist) < self.stuck_progress_threshold:
            if (now - self.progress_timer) > self.stuck_timeout:
                if self.navigation_active and self.cancel_reason == "NONE":
                    self.get_logger().warn(
                        "Stuck at obstacle/corner; skipping this waypoint."
                    )
                    self.cancel_reason = "STUCK"
                    self.cancel_nav_goal()
                    return
        else:
            # Progress made; reset timer
            self.last_dist_remaining = dist
            self.progress_timer = now

    def goal_response_callback(self, future) -> None:
        goal_handle = future.result()
        if not goal_handle or not goal_handle.accepted:
            self.get_logger().warn("Nav2 goal rejected.")
            self.navigation_active = False
            self.state = self.STATE_IDLE
            return

        self.goal_handle = goal_handle
        self.navigation_active = True
        result_future = goal_handle.get_result_async()
        result_future.add_done_callback(self.get_result_callback)
        self.get_logger().info("Nav2 goal accepted.")

    def get_result_callback(self, future) -> None:
        status = future.result().status
        self.get_logger().info(f"Nav2 goal finished with status: {status}")
        self.navigation_active = False
        self.goal_handle = None

        # Manage waypoint list based on status & cancel_reason
        if self.current_waypoint is not None:
            if status == GoalStatus.STATUS_SUCCEEDED:
                self.remove_current_waypoint()
            elif status == GoalStatus.STATUS_CANCELED:
                if self.cancel_reason in ["REACHED", "STUCK"]:
                    self.remove_current_waypoint()
                else:
                    self.get_logger().info(
                        "Goal cancelled due to object; keeping waypoint for later."
                    )
            elif status == GoalStatus.STATUS_ABORTED:
                self.remove_current_waypoint()

        self.current_waypoint = None

        if self.state == self.STATE_NAVIGATING:
            self.state = self.STATE_IDLE

    def cancel_nav_goal(self) -> None:
        if self.goal_handle is not None and self.navigation_active:
            self.goal_handle.cancel_goal_async()
        self.goal_handle = None
        self.navigation_active = False
        self.stop_robot()

    def remove_current_waypoint(self) -> None:
        if (
            self.current_waypoint is not None
            and self.current_waypoint in self.unvisited_waypoints
        ):
            self.unvisited_waypoints.remove(self.current_waypoint)

    # ============================================================
    # Object localisation & markers
    # ============================================================

    def estimate_object_position(
        self, detection: dict, dist: Optional[float] = None
    ) -> Tuple[Optional[float], Optional[float]]:
        if not self.have_pose:
            return None, None

        # 1. Distance: LIDAR measures surface; add radius for centre
        surface_dist = dist if dist is not None else self.safe_object_distance
        object_radius = 0.15  # 15 cm radius approx
        d = surface_dist + object_radius

        # 2. Angle from camera offset
        # FOV ~ 62 degrees (~1.08 rad). offset is [-1, 1] left->right.
        fov = 1.08
        angle_correction = -detection["offset"] * (fov / 2.0)

        yaw = self.robot_pose["yaw"] + angle_correction
        x = self.robot_pose["x"]
        y = self.robot_pose["y"]

        obj_x = x + d * math.cos(yaw)
        obj_y = y + d * math.sin(yaw)
        return obj_x, obj_y

    def is_duplicate_object(
        self, obj_type: str, obj_x: float, obj_y: float, min_dist: float = 1.0
    ) -> bool:
        for existing in self.found_objects:
            if existing["type"] != obj_type:
                continue
            dx = existing["x"] - obj_x
            dy = existing["y"] - obj_y
            if math.hypot(dx, dy) < min_dist:
                return True
        return False

    def publish_object_marker(self, obj_type: str, obj_x: float, obj_y: float) -> None:
        marker = Marker()
        marker.header.frame_id = self.map_frame
        marker.header.stamp = self.get_clock().now().to_msg()
        marker.ns = "detected_objects"
        marker.id = self.marker_id_counter
        self.marker_id_counter += 1

        marker.type = Marker.SPHERE
        marker.action = Marker.ADD
        marker.pose.position.x = obj_x
        marker.pose.position.y = obj_y
        marker.pose.position.z = 0.1
        marker.pose.orientation.w = 1.0
        marker.scale.x = 0.3
        marker.scale.y = 0.3
        marker.scale.z = 0.3

        # Red for hydrant, green for trash can
        if obj_type == "hydrant":
            marker.color.r = 1.0
            marker.color.g = 0.0
        else:
            marker.color.r = 0.0
            marker.color.g = 1.0
        marker.color.b = 0.0
        marker.color.a = 1.0

        self.marker_pub.publish(marker)

    def publish_waypoints_markers(self) -> None:
        marker_array = MarkerArray()

        # Clear old markers
        delete_all = Marker()
        delete_all.action = Marker.DELETEALL
        marker_array.markers.append(delete_all)

        # Current waypoint (yellow sphere)
        if self.current_waypoint is not None:
            m = Marker()
            m.header.frame_id = self.map_frame
            m.header.stamp = self.get_clock().now().to_msg()
            m.ns = "current_waypoint"
            m.id = 0
            m.type = Marker.SPHERE
            m.action = Marker.ADD
            m.pose.position.x = self.current_waypoint[0]
            m.pose.position.y = self.current_waypoint[1]
            m.pose.position.z = 0.3
            m.scale.x = 0.4
            m.scale.y = 0.4
            m.scale.z = 0.4
            m.color.r = 1.0
            m.color.g = 1.0
            m.color.b = 0.0
            m.color.a = 1.0
            marker_array.markers.append(m)

        # Remaining waypoints (small yellow cubes)
        for i, wp in enumerate(self.unvisited_waypoints):
            m = Marker()
            m.header.frame_id = self.map_frame
            m.header.stamp = self.get_clock().now().to_msg()
            m.ns = "unvisited_waypoints"
            m.id = i + 1
            m.type = Marker.CUBE
            m.action = Marker.ADD
            m.pose.position.x = wp[0]
            m.pose.position.y = wp[1]
            m.pose.position.z = 0.1
            m.scale.x = 0.15
            m.scale.y = 0.15
            m.scale.z = 0.15
            m.color.r = 1.0
            m.color.g = 1.0
            m.color.b = 0.0
            m.color.a = 0.6
            marker_array.markers.append(m)

        self.waypoint_marker_pub.publish(marker_array)

    def handle_new_detection(self, detection: dict) -> None:
        obj_type = detection["type"]
        obj_x, obj_y = self.estimate_object_position(detection, self.front_distance)
        if obj_x is None:
            return

        if self.is_duplicate_object(obj_type, obj_x, obj_y, min_dist=1.0):
            self.get_logger().info(
                f"Ignoring duplicate {obj_type} near ({obj_x:.2f}, {obj_y:.2f})"
            )
            return

        self.found_objects.append({"type": obj_type, "x": obj_x, "y": obj_y})
        self.publish_object_marker(obj_type, obj_x, obj_y)
        self.get_logger().info(
            f"Stored {obj_type} at ({obj_x:.2f}, {obj_y:.2f}) and published marker."
        )

    # ============================================================
    # Motion & exploration helpers
    # ============================================================

    def stop_robot(self) -> None:
        self.cmd_pub.publish(Twist())

    def get_closest_waypoint(self) -> Optional[Tuple[float, float]]:
        if not self.unvisited_waypoints:
            return None
        best = None
        best_d = float("inf")
        for wp in self.unvisited_waypoints:
            dx = wp[0] - self.robot_pose["x"]
            dy = wp[1] - self.robot_pose["y"]
            d = math.hypot(dx, dy)
            if d < best_d:
                best_d = d
                best = wp
        return best

    # ============================================================
    # Main control loop & FSM
    # ============================================================

    def control_loop(self) -> None:
        self.loop_count += 1

        # Periodic markers for RViz
        if self.loop_count % 20 == 0:
            self.publish_waypoints_markers()

        # Global runtime limit
        elapsed = time.time() - self.start_wall_time
        if elapsed > self.max_runtime_sec and self.state != self.STATE_FINISHED:
            self.get_logger().warn("Max runtime reached; stopping exploration.")
            self.cancel_nav_goal()
            self.stop_robot()
            self.state = self.STATE_FINISHED

        if self.state == self.STATE_FINISHED:
            # Do nothing else
            return

        detection = self.current_detection
        front = self.front_distance

        # Global interrupt: new object detection
        if detection is not None and self.state not in [
            self.STATE_TURN_TO_OBJECT,
            self.STATE_APPROACH_OBJECT,
            self.STATE_BACKING_UP,
            self.STATE_SPINNING_AWAY,
        ]:
            should_chase = True
            if front is not None and self.have_pose:
                est_x, est_y = self.estimate_object_position(detection, dist=front)
                if est_x is not None and self.is_duplicate_object(
                    detection["type"], est_x, est_y, min_dist=1.5
                ):
                    should_chase = False

            if should_chase:
                self.get_logger().info(
                    f"Object detected ({detection['type']}). Interrupting Nav2."
                )
                self.cancel_reason = "OBJECT"
                if self.navigation_active:
                    self.cancel_nav_goal()
                self.state = self.STATE_TURN_TO_OBJECT
                # don't `return` here – allow state handling below

        # ---------------- FSM ----------------
        if self.state == self.STATE_IDLE:
            if not self.have_pose:
                if self.loop_count % 20 == 0:
                    self.get_logger().info("Waiting for AMCL pose...")
                return

            if self.unvisited_waypoints:
                target = self.get_closest_waypoint()
                if target is None:
                    # Shouldn't happen, but be safe
                    self.get_logger().info("No valid waypoint found.")
                    return
                self.current_waypoint = target
                if self.send_nav_goal(target[0], target[1]):
                    self.state = self.STATE_NAVIGATING
            else:
                self.get_logger().info(
                    "All waypoints visited. Exploration complete (before timeout)."
                )
                self.stop_robot()
                self.state = self.STATE_FINISHED

        elif self.state == self.STATE_NAVIGATING:
            # Nav2 is in control; feedback & result callbacks handle transitions.
            pass

        elif self.state == self.STATE_TURN_TO_OBJECT:
            twist = Twist()
            if detection is None:
                # Lost object; resume nav
                self.state = self.STATE_IDLE
            else:
                offset = detection["offset"]
                if abs(offset) < self.center_tolerance:
                    self.state = self.STATE_APPROACH_OBJECT
                else:
                    twist.angular.z = -self.max_angular_speed * offset
            self.cmd_pub.publish(twist)

        elif self.state == self.STATE_APPROACH_OBJECT:
            twist = Twist()
            if detection is None:
                # Lost object; return to exploration
                self.state = self.STATE_IDLE
            else:
                offset = detection["offset"]
                twist.angular.z = -self.max_angular_speed * offset
                twist.linear.x = 0.1

                if front is not None and front < self.safe_object_distance:
                    self.stop_robot()
                    self.handle_new_detection(detection)
                    self.current_detection = None
                    self.state = self.STATE_BACKING_UP
                    self.backup_counter = 15  # ~1.5s at 10 Hz
            self.cmd_pub.publish(twist)

        elif self.state == self.STATE_BACKING_UP:
            twist = Twist()
            if self.backup_counter > 0:
                twist.linear.x = -0.1
                self.backup_counter -= 1
            else:
                self.state = self.STATE_SPINNING_AWAY
                self.turn_away_counter = 30  # ~3s
            self.cmd_pub.publish(twist)

        elif self.state == self.STATE_SPINNING_AWAY:
            twist = Twist()
            if self.turn_away_counter > 0:
                twist.angular.z = self.max_angular_speed
                self.turn_away_counter -= 1
            else:
                self.state = self.STATE_IDLE
                self.get_logger().info(
                    "Object handling completed. Resuming Nav2 exploration."
                )
            self.cmd_pub.publish(twist)


def main(args=None) -> None:
    rclpy.init(args=args)
    node = TreasureHuntNode()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.stop_robot()
        node.destroy_node()
        rclpy.shutdown()


if __name__ == "__main__":
    main()
