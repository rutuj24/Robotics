import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist
import random
from enum import Enum
import math

class State(Enum):
    RANDOM_WALK = 0
    FOLLOW_WALL = 1
    AVOID_OBSTACLE = 2

class Minitask2(Node):

    def __init__(self):
        super().__init__('minitask2')
        self.front = float('inf')
        self.left = float('inf')
        self.right = float('inf')
        self.front_left = float('inf')
        self.front_right = float('inf')
        
        self.state = State.RANDOM_WALK
        self.avoid_direction = None
        self.wall_following_side = 'left'

        self.rw_forward_time = 0
        self.rw_turn_time = 0
        self.rw_moving_forward = True

        self.obstacle_threshold = 0.5   
        self.wall_threshold = 1.0       
        self.wall_distance = 0.4        
        self.kp = 1.5                   
        self.linear_speed = 0.15        
        self.angular_speed = 0.5        

        self.pub = self.create_publisher(Twist, '/cmd_vel', 10)
        qos = QoSProfile(depth=10, reliability=ReliabilityPolicy.BEST_EFFORT)
        self.sub = self.create_subscription(LaserScan, '/scan', self.lidar_callback, qos)

        self.create_timer(0.1, self.control_loop)

    def lidar_callback(self, msg):
        n = len(msg.ranges)
        def safe_min(values):
            vals = [r for r in values if not math.isinf(r) and not math.isnan(r)]
            return min(vals) if vals else float('inf')
        self.front = safe_min(msg.ranges[0:10] + msg.ranges[-10:])
        self.left = safe_min(msg.ranges[85:95])
        self.right = safe_min(msg.ranges[265:275])
        self.front_left = safe_min(msg.ranges[20:40])
        self.front_right = safe_min(msg.ranges[-40:-20])

    def control_loop(self):
        twist = Twist()
        
        if self.left < self.wall_threshold :
            self.wall_following_side = "left"
        elif self.right < self.wall_threshold :
            self.wall_following_side = "right"

        if self.front < self.obstacle_threshold or self.front_left < self.obstacle_threshold or self.front_right < self.obstacle_threshold:
            if self.state != State.AVOID_OBSTACLE:
                self.state = State.AVOID_OBSTACLE
                if self.front_left > self.front_right:
                    self.avoid_direction = 'left'
                else:
                    self.avoid_direction = 'right'
                self.get_logger().info(f"STATE: OBSTACLE AVOID -- turning {self.avoid_direction.upper()}")

            twist.linear.x = 0.0
            twist.angular.z = self.angular_speed if self.avoid_direction == 'left' else -self.angular_speed

            if self.front > self.obstacle_threshold*1.35 and self.front_left > self.obstacle_threshold*1.35 and self.front_right > self.obstacle_threshold*1.35 :
                self.state = State.RANDOM_WALK
                self.avoid_direction = None
        
        elif ((self.wall_following_side == 'left' and self.left < self.wall_threshold) or
              (self.wall_following_side == 'right' and self.right < self.wall_threshold)):
            if self.state != State.FOLLOW_WALL:
                self.state = State.FOLLOW_WALL
                self.get_logger().info("STATE: FOLLOW_WALL")
            twist.linear.x = self.linear_speed
            if self.wall_following_side == 'left':
                error = self.left - self.wall_distance
                twist.angular.z = self.kp * error
            else:
                error = self.right - self.wall_distance
                twist.angular.z = -self.kp * error
        else:
            if self.state != State.RANDOM_WALK:
                self.rw_forward_time, self.rw_turn_time = 0, 0
                self.rw_moving_forward = True
                self.state = State.RANDOM_WALK
                self.get_logger().info("STATE: RANDOM_WALK")
            if self.rw_moving_forward:
                twist.linear.x = self.linear_speed
                twist.angular.z = 0.0
                self.rw_forward_time += 0.1
                if self.rw_forward_time > random.uniform(1.0, 3.0):
                    self.rw_moving_forward = False
                    self.rw_forward_time = 0
                    self.rw_turn_amt = random.choice([-1, 1]) * random.uniform(math.pi/6, math.pi)
                    self.rw_turn_time = 0
            else:
                twist.linear.x = 0.0
                twist.angular.z = self.angular_speed if self.rw_turn_amt > 0 else -self.angular_speed
                self.rw_turn_time += 0.1
                if self.rw_turn_time > abs(self.rw_turn_amt/self.angular_speed):
                    self.rw_moving_forward = True
                    self.rw_turn_time = 0

        self.pub.publish(twist)

def main(args=None):
    rclpy.init(args=args)
    node = Minitask2()
    rclpy.spin(node)

    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
